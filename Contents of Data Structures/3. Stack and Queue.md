## 1.堆疊 (Stack)
### 核心定義：堆疊是一種遵循 「後進先出」(Last-In-First-Out, LIFO) 原則的線性資料結構。
### 運作方式：所有的資料插入與移除都發生在同一端，稱為 「頂端」(Top)」。
### 主要操作 (ADT)：
- CreateS: 建立一個指定大小的空堆疊。
- Push: 將元素加入堆疊頂端。
- Pop: 從堆疊頂端移除並回傳元素。
- IsFull / IsEmpty: 檢查堆疊是否已滿或為空。
- Peek: 查看頂端元素但不移除。
### 實作細節：
- 陣列實作：使用 top 變數追蹤索引（初始通常為 -1）。插入時 top 增加，移除時 top 減少。
- 鏈結串列實作：使用 top 指標指向頭節點，每次 Push 或 Pop 都在頭部進行，具備動態擴展優勢。
### 應用場景：復原功能 (Undo)、函式呼叫、運算式求值（如河內塔問題）。

## 2.佇列 (Queue) 
### 核心定義：佇列是一種遵循 「先進先出」(First-In-First-Out, FIFO) 原則的線性資料結構。
### 運作方式：資料從 「後端」(Rear) 加入，並從 「前端」(Front) 移除，就像排隊買票一樣。
### 主要操作 (ADT)：
- CreateQ: 建立空佇列。
- AddQ (Enqueue): 在後端加入元素。
- DeleteQ (Dequeue): 從前端移除元素。
- IsFullQ / IsEmptyQ: 判斷佇列狀態。
### 實作細節：
- 陣列實作：通常設計為環形陣列(Circular Array)以重用空間。
- 鏈結串列實作：需要兩個指標 front 與 rear 分別指向頭部與尾部，以維持 O(1) 的操作效率。
### 應用場景：任務排程、資源共享（如印表機佇列）、緩衝區 (I/O Buffering)。

## 3.堆疊 vs 佇列詳細對比
### 存取原則與邏輯：
- 堆疊遵循後進先出(LIFO)原則，最後加入的元素會最先被移除，概念上如同疊放的盤子。
- 佇列遵循先進先出(FIFO)原則，最早進入的元素會最先被處理，就像在櫃檯排隊等候的人群。
### 資料進出的方向：
- 堆疊中，所有的插入(Push)與移除(Pop)操作都發生在同一端，這端被稱為頂端(Top)。
- 佇列的進出發生在不同端：新資料從後端(Rear)進入，而移除操作則在前端(Front)進行。
### 實作所需的指標與索引：
- 堆疊的實作相對簡單，通常只需要一個稱為 top 的整數索引或指標來追蹤頂端位置。
- 佇列的實作則較為複雜，至少需要兩個指標：front 指向第一個元素，以及 rear 指向最後一個元素，有時還會額外使用 count 變數來簡化判斷。
### 陣列實作的挑戰與處理：
- 堆疊非常直觀，僅需根據資料增減來移動 top 索引，並檢查是否超過容量限制。
- 佇列為了能重複利用已經移除資料後的空間，通常必須實作為環形陣列(Circular Array)，需使用模數運算(Modulo arithmetic)來處理，例如(rear + 1) % MAX_SIZE）。
### 實作時的額外負擔:
- 堆疊主要的負擔在於必須持續檢查溢位 (Overflow) 與下溢 (Underflow) 狀態。
- 佇列除了基本的邊界檢查外，還必須妥善管理環形緩衝邏輯，並小心處理佇列變空時的指標歸位情形。
  
## 4.實作方式之比較：陣列 vs 鏈結串列
### 針對這兩種資料結構的底層實作進行比較：
#### 記憶體管理：
- 陣列 (Array)：空間預先分配，可能造成浪費；若空間不足需重新分配 (Resizing) 並複製資料。
- 鏈結串列 (Linked List)：動態分配記憶體，不限固定大小，但每個節點需額外儲存指標空間 (Pointer overhead)。
#### 效能：
- 兩者在一般情況下進行插入或移除的時間複雜度皆為 O(1)。
- 陣列實作在擴展容量時會有額外開銷；鏈結串列則在每次操作時需負擔 malloc/free 的記憶體管理成本。
#### 溢位處理：
- 固定大小的陣列容易發生溢位 (Overflow)。
- 鏈結串列除非系統記憶體耗盡，否則不會溢位。
