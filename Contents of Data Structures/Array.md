## 1.陣列的基本定義與性質
### 定義：陣列是存儲在連續記憶體位置(contiguous memory locations)的元素集合，每個元素都可以透過索引(index)直接存取。
#### 特性：
- 固定大小：通常在宣告時即確定大小。
- 相同型別：所有元素通常屬於同一種資料型別，便於高效存取。
- 常數時間存取：提供 O(1) 的元素訪問速度。

## 2.陣列的維度與表示
### 從一維到三維的靜態陣列表示法：
- 一維陣列 (1D)：基本的線性排列，如 int array。
- 二維陣列 (2D)：由**列（row）與行（column）**組成，通常以 array[row][column] 存取。
- 三維陣列 (3D)：可以想像成多個平面（planes）組成，每個平面是一個 2D 矩陣，存取方式為 array[plane][row][column]。

## 3.陣列作為抽象資料型別 (ADT)
### 陣列在邏輯上被定義為一組 <索引, 值> (index, value) 的配對。其核心操作包括：
- Create(j, list)：建立一個 j 維陣列。
- Retrieve(A, i)：若索引 i 合法，回傳對應的元素值。
- Store(A, i, x)：在索引 i 處存入值 x。
- 其他操作還包括：Update（更新）、Insert（插入）、Delete（刪除）、Traverse（遍歷）、Search（搜尋）與 Resize（重新調整大小）。

## 4.靜態與動態陣列 (Static vs. Dynamic)
### 根據記憶體配置的時間點，陣列分為兩類：
#### 靜態陣列 (Static Array)：
- 長度固定，在**編譯時（compile time）**決定。
- 通常存儲於**Stack**空間。
#### 動態陣列 (Dynamic Array)：
- 長度可變，在**執行時（runtime）**分配空間。
- 在 C 語言中透過 malloc() 分配，realloc() 調整大小，並須使用 free() 釋放記憶體以避免記憶體洩漏。
- 通常存儲於**Heap**空間。
- 關鍵觀察：當使用 realloc 擴張陣列時，其起始記憶體位址可能會改變，因為系統可能需要找尋更大的連續空間來放置增長後的陣列。

## 5.C++ STL 中的陣列容器
### 講義對比了 C++ 標準模板庫 (STL) 中的兩大容器：
#### std::array (靜態容器)
- 大小與記憶體：std::array 的大小在編譯時即固定，無法在程式執行過程中改變。它通常將資料存儲在**棧（Stack）**空間中。
- 效能與空間：由於其靜態特性，它擁有最快的存取速度，且記憶體使用量極小，沒有額外的管理開銷。
- 適用場景：最適合用於已知且固定數據量的情況。
- 核心操作：支援基本的元素存取（如 at、operator[]、front、back、data）、疊代器（Iterators）操作，以及檢查容器是否為空（empty）或獲取大小（size、max_size）。在修改器方面，僅支援填充值（fill）與交換內容（swap）。
#### std::vector (動態容器)
- 大小與記憶體：std::vector 的大小在執行時是可變的，能根據需求動態增長。其資料存儲於**堆（Heap）**空間。
- 效能與空間：雖然存取速度很快，但因為需要動態管理記憶體，會存在些微的額外開銷（overhead）。此外，為了維持增長的靈活性，它會額外佔用一個容量緩衝區（capacity buffer），導致記憶體使用量較高。
- 適用場景：當數據量需求會變動或無法預先確定時，它是高度靈活的首選。
- 核心操作：除了擁有與 std::array 相同的基本存取和疊代器功能外，它還具備強大的動態修改功能。這包括在末尾新增元素（push_back）、刪除末尾元素（pop_back）、插入（insert）、刪除（erase）以及調整大小（resize）。
- 容量管理：它提供了專屬的機制來管理內存，例如預留空間（reserve）、查看當前分配的容量（capacity），以及釋放多餘空間以優化記憶體（shrink_to_fit）。
#### 關鍵差異總結
- 靈活性：std::array 的靈活性較低，而 std::vector 具有極高的靈活性。
- 實作原理：std::array 本質上是對傳統靜態陣列的封裝，而 std::vector 則是動態陣列的實作，當內部空間不足時，可能會涉及記憶體的重新配置與元素搬移。
- 功能完整性：std::vector 提供的成員函數遠多於 std::array，特別是在容器內容的增刪與記憶體管理方面。
- 陣列的操作複雜度在兩種容器中基本一致：隨機存取與更新均為 O(1)，但對於動態容器 std::vector 而言，插入與刪除操作通常需要 O(n) 的時間，因為這涉及大量元素的位移。

## 6.陣列演算法：排序與搜尋
### 陣列是執行排序與搜尋演算法的基礎容器：
#### 排序演算法 (Sorting)：
- 氣泡排序 (Bubble Sort)：重複交換相鄰且順序錯誤的元素。
- 選擇排序 (Selection Sort)：每次尋找剩餘部分的最小值並置於前端。
- 插入排序 (Insertion Sort)：將元素逐一插入已排序好的子陣列中。
#### 搜尋演算法 (Searching)：
- 線性搜尋 (Linear Search)：適用於未排序陣列，需檢查每個元素。
- 二分搜尋 (Binary Search)：僅適用於已排序陣列，透過折半搜尋大幅提升效率。

## 7.操作複雜度分析
### 陣列在不同操作下的時間複雜度表現如下：
- 存取 (Access)：O(1)。
- 更新 (Update)：O(1)。
- 插入 (Insert) / 刪除 (Delete)：O(n)，因為需要搬移（shift）其他元素以維持連續性。
- 搜尋 (Search)：線性搜尋為 O(n)，二分搜尋為 O(logn)。

## 8.不同資料型別的陣列
- 整數/浮點數陣列：存儲各類數值（如 short, int, float, double 等）。
- 字元陣列與字串：在 C 語言中，字串本質上是以空字元 \0 結尾的字元陣列。
- 字串陣列：可以是單一字元陣列，也可以是字串指標陣列（例如 char *words）。

## 9.實際應用案例
- 基礎結構：陣列常用於實現其他資料結構，如堆疊（Stacks）隊列（Queues）。
