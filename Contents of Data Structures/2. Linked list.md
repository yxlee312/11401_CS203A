## 1.核心概念與定義
### 定義：鏈結串列是一種線性資料結構，由一系列節點（Nodes）並非連續存放，而是透過指標（Pointer）相互連結。
#### 節點組成：每個節點包含兩個基本部分：
- 資料（Data）：儲存實際數值。
- 指標（Reference/Pointer）：指向下一個節點的記憶體位址。
#### 終止條件：串列的末端通常以一個 NULL 指標作為結束標記。
#### 存取特性：不像陣列可以透過索引隨機存取，鏈結串列必須從**頭節點（Head）**開始依序遍歷才能找到特定元素。
## 2.鏈結串列與陣列的比較
### 這是理解資料結構選擇的關鍵，兩者在不同面向有顯著差異：
#### 記憶體分配：陣列使用連續的記憶體區塊，必須在宣告時定義大小（靜態）；鏈結串列則是動態分配，各個節點分散在記憶體中。
#### 存取效率（Access）：陣列支持直接透過索引存取，效率為 O(1)；鏈結串列僅能從頭節點開始序遍歷，效率為 O(n)。
#### 插入與刪除（Insertion/Deletion）：陣列在中間執行這些操作時非常耗時，因為需要大量移動（Shift）元素；鏈結串列則非常高效，若已知節點指標，效率可達 O(1)。
#### 額外開銷：鏈結串列需要額外的記憶體來儲存指標，而陣列除了儲存資料本身外沒有其他開銷。
#### 快取效能（Cache Performance）：陣列由於記憶體連續，對硬體快取更友善；鏈結串列的節點可能散落在記憶體各處，效能較差。
## 3.抽象資料型別 (ADT) 與基本操作
### 根據來源，一個標準的鏈結串列 ADT 應包含以下功能：
#### Create()：建立空的串列。
#### IsEmpty(L)：檢查是否為空。
#### Length(L)：計算節點總數。
#### Retrieve(L, p)：取得特定位置的資料。
#### Search(L, x)：尋找特定值出現的位置。
#### Insert/Delete/Update：在指定位置插入、刪除或更新節點。
### 插入與刪除的操作邏輯：
#### 插入節點（中間插入）：
- 遍歷尋找目標位置。
- 將新節點的 next 指向目標的下一個節點。
- 將目標節點的 next 改為指向新節點。
#### 刪除節點：
- 需要追蹤「前一個節點（Prev）」與「目標節點（Target）」。
- 令 Prev->next = Target->next，跳過目標節點。
- 釋放記憶體（free/delete）：這是 C/C++ 實作中至關重要的一步，否則會造成記憶體洩漏。
## 4.鏈結串列的變化 (Variations)
### 單向鏈結串列 (Singly Linked List)：最基礎形式，節點僅指向下一個節點。
### 雙向鏈結串列 (Doubly Linked List)：
- 每個節點有 next 和 prev 兩個指標。
- 優點：可以雙向導覽，操作更具靈活性。
### 環狀鏈結串列 (Circular Linked List)：
- 最後一個節點的 next 指向頭節點，形成一個環。
- 特點：沒有明確的末端（NULL），遍歷時更具彈性。
## 5.排序 (Sorting)
### 如何對鏈結串列進行選擇排序（Selection Sort），主要有兩種策略：
- 交換數值（Swap the value）：僅更換節點內的 data，結構指標不動。實作較簡單。
- 交換指標（Swap the pointer）：直接改變節點間的連結關係。雖然邏輯較複雜，但在資料量大時效能較佳，因為不需要移動實際的大型資料物件。
## 6.實作注意事項與技巧
### 虛擬節點（Dummy/Sentinel Nodes）：在實作排序或複雜插入時，使用 dummy node 可以簡化處理邊界情況（如更改頭節點）的代碼。
### 記憶體管理：
- 在 C 語言中使用 malloc() 分配與 free() 釋放。
- 在 C++ 中使用 new 運算子，並務必在解構子（Destructor）中循序刪除所有節點以釋放記憶體。
### 節點交換陷阱：在交換兩個相鄰節點時，必須注意指標的依賴性，錯誤的賦值順序會導致串列斷裂或形成無限迴圈。
## 7.實際應用場景
### 鏈結串列常用於以下情境：
#### 作業系統記憶體管理。
#### 實作其他資料結構：如堆疊（Stacks）、佇列（Queues）、雜湊表（Hash tables）的碰撞處理。
