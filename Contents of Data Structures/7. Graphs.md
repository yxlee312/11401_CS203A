## 1.Graph的定義與基本概念
#### 數學定義：Graph G=(V,E)由頂點(Vertices/Nodes)的集合V與邊(Edges/Links)的集合E組成。
### 組成：
#### 頂點(Vertex）：代表實體（如社交網路中的人或地圖上的地點）。
#### 邊(Edge）：代表實體間的關係。邊可以帶有方向（Direction）、權重(Weight)標籤(Label）。
#### 子圖(Subgraph）：若G′的頂點與邊集合皆為G的子集，則G′為G的子圖。
#### 分支度(Degree)：
- 無向圖：與頂點相連的邊數。
- 有向圖：分為In-degree(指向頂點的邊)與Out-degree(從頂點出發的邊）。
## 2.Graph的分類
### 根據邊的特性與連通性，Graph可分為以下幾類：
#### 有向圖(Digraph)與無向圖：邊是否有特定方向(如Instagram的追蹤關係是有向的）。
#### 加權圖(Weighted)與不加權圖：邊是否帶有數值(如Google Maps中的距離）。
#### 循環圖(Cyclic)與無環圖(Acyclic)：是否包含路徑可回到起點。
#### 連通圖(Connected)與非連通圖(Disconnected)：圖中任意兩點是否皆有路徑相連。
## 3.Graph的表示方式(Representations)
### Graph主要透過兩種常見的資料結構來呈現：鄰接矩陣(Adjacency Matrix)、鄰接串列(Adjacency List)，兩者在空間利用率與運算效率上各有優劣。
#### 鄰接矩陣(Adjacency Matrix)：這是一種使用V×V二維陣列來記錄頂點間是否存在邊的表示法。
- 優點與適用場景：其最大的優勢在於邊的查詢速度極快，只需O(1)的時間複雜度即可確認任意兩點間是否有邊相連，實作邏輯簡單，適合處理邊數極多的稠密圖（Dense graphs），或是需要頻繁存取權重的演算法（如 Floyd-Warshall）。
- 缺點與限制：無論Graph中邊的數量多少，都必須消耗O(V2)的空間。對於大多數現實世界中的稀疏圖(Sparse graphs)(如社交網路、地圖)來說，這種方式會造成大量的記憶體浪費。此外，若要找出某個頂點的所有鄰居，必須掃描整列陣列，時間複雜度為 O(V)；且在動態新增或刪除頂點時也較為困難。
### 鄰接串列 (Adjacency List)：這種方式是為每個頂點儲存一個鄰居清單，僅記錄實際存在的邊。
- 優點與適用場景：它非常節省空間，空間複雜度僅為O(V+E)，是處理大規模稀疏圖（擁有數百萬個節點）的理想選擇。在執行廣度優先搜尋(BFS)或深度優先搜尋(DFS)等遍歷演算法時，效率極高，因為它能直接存取鄰居節點(複雜度為O(deg(v))）。同時在動態插入或刪除邊時也非常方便:(O(1)）。
- 缺點與限制：若要檢查特定兩點 (u,v) 之間是否存在邊，必須搜尋該頂點的整個串列，時間複雜度會退化至 O(deg(u))。在實作上也相對複雜，需要處理節點與指標（Pointers），且若使用大量小型鏈結串列節點，可能會產生額外的記憶體開銷。
• 總結比較與建議：根據來源建議，當Graph中大多數元素為零時，應優先選擇鄰接串列以達到最高的空間效率。反之，若圖形接近完全連通，鄰接矩陣則能在維持簡單實作的同時提供更快的邊查詢功能。
## 4.圖形遍歷(Graph Traversal)
### 與樹狀結構不同，Graph遍歷必須使用visited[]陣列來記錄已存取的節點，以防止因循環(Cycles)導致的無窮迴圈。
#### 廣度優先搜尋(BFS)：
- 機制：使用隊列(Queue)實現，類似樹的層序遍歷(Level-order)。
- 特性：按距離起點的步數(度數)逐層探索。
#### 深度優先搜尋(DFS)：
- 機制：使用堆疊(Stack)或遞迴實現，類似樹的前序遍歷(Preorder)。
- 特性：沿著一條路徑儘可能深地探索，具備回溯(Backtracking)與路徑記憶功能。
## 5.圖形 vs 樹(Graph vs Tree)
### 定義與基本結構：樹為一個連通且無循環(Acyclic)的圖。Graph則是一種更廣義的結構，可以呈現任何形狀，且允許循環(Cycles)的存在。
### 連通性與連通組件：樹在結構上必須是永遠連通的，這意味著任意兩個節點之間都存在路徑。Graph則可能是非連通(Disconnected)的，圖中可能存在彼此孤立的節點。
### 階層性與關係準則：樹具有明確的階層結構，其節點間的關係建立在父子(Parent-child)，Graph沒有固定的階層，其運算基礎建立在鄰居相鄰關係(Neighbor adjacency)上。
### 路徑與方向性：樹中任意兩個節點之間僅存在一條路徑。但在圖形中，節點之間可能存在多條路徑。此外，圖形的邊可以是有向的或無向的，而樹通常被視為無向且無循環的結構。
### 遍歷演算法的關鍵差異：兩者都使用深度優先搜尋(DFS)與廣度優先搜尋(BFS)，但實作上有顯著不同。樹的遍歷通常是確定的（如前序、中序、後序或層序），且不需要額外記錄已存取的節點。圖形的遍歷則必須使用visited[]陣列來標記已存取的頂點，這是為了處理圖中的循環問題，防止陷入無窮迴圈。此外，圖形遍歷可以從任何頂點作為起點，且其結果會受到鄰接表示方式(如鄰接串列或鄰接矩陣)的影響。
## 6.抽象資料型別(ADT)
### Graph的常用功能函數包括：
#### Create()：建立空圖。
#### InsertVertex(v)/DeleteVertex(v)：新增或移除頂點。
#### InsertEdge(v1,v2)/DeleteEdge(v1,v2)：新增或移除邊。
#### Adjacent(v)：回傳所有與v相鄰的頂點列表。
