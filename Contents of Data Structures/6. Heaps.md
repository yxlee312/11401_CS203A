## 1.堆疊的基本定義與特性
### 堆疊是一種特殊的完全二元樹（Complete Binary Tree），必須同時符合以下兩種特性：
#### 形狀特性（Shape Property）：
- 堆疊必須是一棵完全二元樹，這意味著除了最後一層外，每一層都必須填滿。
- 最後一層的節點必須由左至右依序填入。
- 這種特性保證了堆疊可以高效地存儲在陣列(Array)中，且中間不會產生空隙。
#### 堆疊排序特性（Heap-Order Property）：
- 最大堆疊（Max Heap）：每個父節點的值都大於或等於其子節點的值(Parent≥Children），因此最大值永遠在根節點。
- 最小堆疊（Min Heap）：每個父節點的值都小於或等於其子節點的值(Parent≤Children），因此最小值永遠在根節點。
## 2.堆疊的陣列表示法
### 由於堆疊是完全二元樹，我們不需要使用複雜的指標，直接用陣列即可呈現。例如：
- 最大堆疊範例：樹狀結構為 (50) -> 左子 30, 右子 40，對應的陣列表示即為[50, 30, 40]。
- 存儲效率：這種方式最為精簡且節省空間。
## 3.核心操作流程
### 堆疊的操作主要圍繞著「維持完全二元樹形狀」與「恢復排序特性」進行：
#### 插入元素（Insertion / Sift-up）：
- 步驟 1：將新節點放在最後一層最左邊的空位，以維持完全二元樹的形狀。
- 步驟 2：將新節點與其父節點比較。在最大堆疊中，若新節點較大則與父節點交換。
- 步驟 3：重複此過程，直到滿足堆疊特性或到達根節點為止。
#### 取出根節點（Extract Max/Min / Sift-down）：
- 步驟 1：將根節點取出，並用最後一個葉節點(Last Leaf)遞補根節點的位置。
- 步驟 2：將新的根節點與其較大的子節點(以最大堆疊為例)比較，若子節點較大則交換。
- 步驟 3：重複此過程，直到滿足特性或到達葉節點為止。
## 4.時間複雜度總結
### 堆疊的高效性體現在其對數級的時間複雜度：
- 查看根節點(Peek): O(1)，根節點始終在陣列索引 0 的位置。
- 插入元素(Insert): O(logn)，元素沿著樹高從葉片移向根部（Sift-up）。
- 移除根節點(Extract): O(logn)，元素沿著樹高從根部移向葉片（Sift-down）。
- 修改鍵值(Increase/Decrease Key): O(logn)，視情況使用 Sift-up 或 Sift-down。
- 建立堆疊(Build Heap): O(n)，使用 Floyd 演算法，比連續 n 次插入更高效。
- 堆疊排序(Heapsort): O(nlogn)，執行 n 次取出最大值的操作。
## 5.優先權與實際應用
### 在堆疊中，排序特性即代表優先權(Priority)的編碼規則。
#### 優先權定義：數值可以代表重要性、緊急程度或權重。
#### 對應關係：
- 在最大堆疊中，最大鍵 = 最高優先權。
- 在最小堆疊中，最小鍵 = 最高優先權。
#### 典型應用範例：
- 急診室病人：檢傷分類等級高的優先處理。
- 作業系統調度：剩餘時間最短的工作優先。
- 主要用途：實作優先權佇列(Priority Queue)、排程(Scheduling)以及堆疊排序演算法(Heapsort)。
